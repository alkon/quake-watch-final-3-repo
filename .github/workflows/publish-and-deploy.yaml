name: Publish and deploy the Python App & Helm Chart

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allows manual trigger

jobs:
  build-and-publish:
    runs-on: self-hosted

    permissions:
      contents: read
      packages: write # Crucial for pushing Docker images and Helm charts to GHCR

    outputs:
      chart_name: ${{ steps.extract_metadata_action.outputs.name }} # Access output from the custom action
      image_tag: "latest" # Assuming 'latest' tag is always pushed for the Docker image
      base_chart_version: ${{ steps.extract_metadata_action.outputs.base_version }} # Access output from the custom action
      argocd_app_name: ${{ steps.extract_metadata_action.outputs.app_name }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GH_PAT }}

      - name: Extract Chart Metadata
        id: extract_metadata_action # Assign an ID to the custom action step
        uses: ./.github/actions/extract-chart-metadata
        with:
          chart-path: './k8s' # Pass the base path to your chart directory

#      - name: Build and Push Docker Image to GHCR
#        uses: docker/build-push-action@v5 # Using the recommended action
#        with:
#          context: .
#          push: true
#          tags: ghcr.io/${{ github.repository_owner }}/${{ steps.extract_metadata_action.outputs.name }}:latest


      - name: Build and Push Docker Image to GHCR
        uses: docker/build-push-action@v5 # Using the recommended action
        with:
          context: .
          push: true

          # Use the actual Docker image name 'quake-watch-app' & dynamic app_version from Chart.yaml
          tags: ghcr.io/${{ github.repository_owner }}/quake-watch-app:${{ steps.extract_metadata_action.outputs.base_version }}
          load: false # Keep as false if you don't need to load into local docker daemon
          no-cache: false # Keep as false if you want to use build cache
          pull: false # Keep as false if you don't need to pull base image on every run

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.18.0

      - name: Package & Push Helm Chart to GHCR OCI
        run: |
          CHART_DIR="./k8s/${{ steps.extract_metadata_action.outputs.chart_directory }}" 
          
          # CORRECTED: Explicitly use --version flag for helm package.
          # This ensures the packaged .tgz file (e.g., quake-watch-app-chart-0.3.0.tgz)
          # correctly reflects the chart's version from Chart.yaml.
          echo "Running: helm package \"$CHART_DIR\" --destination . --version \"${{ steps.extract_metadata_action.outputs.base_version }}\""
          CHART_PACKAGE=$(helm package "$CHART_DIR" --destination . --version "${{ steps.extract_metadata_action.outputs.base_version }}" | awk '{print $NF}') 
          echo "Packaged chart filename: $CHART_PACKAGE"
          
          # CRITICAL FIX: The GHCR OCI target should ONLY be the base registry URL.
          # Helm push will infer the chart name (quake-watch-app-chart) and version (0.3.0)
          # from the filename of the packaged chart (CHART_PACKAGE).
          GHCR_OCI_TARGET="oci://ghcr.io/${{ github.repository_owner }}" # Corrected: Removed /quake-watch-app-chart
          echo "Pushing Helm chart to GHCR OCI Repository: $GHCR_OCI_TARGET"
          helm push "$CHART_PACKAGE" "$GHCR_OCI_TARGET" --debug

  deploy:
    runs-on: self-hosted
    needs: build-and-publish

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Kubeconfig for K3D Cluster
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config 
          chmod 600 ~/.kube/config
          echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV

      - name: Get ArgoCD Admin Password
        id: get_argocd_password
        run: |
          ARGO_CD_INITIAL_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "Retrieved ArgoCD Admin Password."
          echo "argocd_password=$ARGO_CD_INITIAL_PASSWORD" >> "$GITHUB_OUTPUT"

      - name: Log in to ArgoCD
        run: |
          argocd login ${{ secrets.ARGO_CD_SERVER }} \
            --username admin \
            --password ${{ steps.get_argocd_password.outputs.argocd_password }} \
            --insecure

      - name: Update ArgoCD Application with Chart.yaml Version and Sync
        run: |
          APP_NAME="${{ needs.build-and-publish.outputs.argocd_app_name }}" 

          CHART_VERSION_FROM_YAML="${{ needs.build-and-publish.outputs.base_chart_version }}" 
          
          echo "Updating ArgoCD application '${APP_NAME}' targetRevision to Chart.yaml version: ${CHART_VERSION_FROM_YAML}"
          kubectl patch application "${APP_NAME}" -n argocd --type='json' -p='[{"op": "replace", "path": "/spec/source/targetRevision", "value":"'"$CHART_VERSION_FROM_YAML"'"}]'

          echo "Triggering sync for ArgoCD application: ${APP_NAME}"
          argocd app sync "$APP_NAME" --prune 

          argocd app wait "$APP_NAME" --health --sync --timeout 300
